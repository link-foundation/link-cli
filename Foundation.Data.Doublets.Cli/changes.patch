--- MixedQueryProcessor.cs
+++ MixedQueryProcessor.cs
@@ -101,6 +101,42 @@ namespace Foundation.Data.Doublets.Cli
                 var allIds = restrictionLinksById.Keys.Union(substitutionLinksById.Keys);

+                // Basic variable support: If both sides have the same variable ID and structure, treat as no-op.
+                var variableIds = allIds.Where(id => id.StartsWith("$")).ToArray();
+                foreach (var varId in variableIds)
+                {
+                    if (restrictionLinksById.TryGetValue(varId, out var varRestrictionLink) 
+                        && substitutionLinksById.TryGetValue(varId, out var varSubstitutionLink))
+                    {
+                        if (AreLinksEquivalent(varRestrictionLink, varSubstitutionLink))
+                        {
+                            // Remove variable from processing as it results in no changes.
+                            allIds = allIds.Except(new[] { varId });
+                        }
+                    }
+                }

                 foreach (var id in allIds)
                 {
                     bool hasRestriction = restrictionLinksById.TryGetValue(id, out var restrictionLinoLink);
@@ -321,6 +357,20 @@ namespace Foundation.Data.Doublets.Cli
        }
    }

+    static bool AreLinksEquivalent(LinoLink a, LinoLink b)
+    {
+        if (a.Id != b.Id) return false;
+        if (a.Values?.Count != b.Values?.Count) return false;
+        if (a.Values == null || b.Values == null) return a.Values == b.Values;
+
+        for (int i = 0; i < a.Values.Count; i++)
+        {
+            var av = a.Values[i];
+            var bv = b.Values[i];
+            if (av.Id != bv.Id) return false; // Simple check for identical structure
+        }
+        return true;
+    }

    static void TryParseLinkId(string? id, LinksConstants<uint> constants, ref uint parsedValue)
    {